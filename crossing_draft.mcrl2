sort 	LightStatus = struct LightOn|LightOff;
	BellStatus = struct BellOn|BellOff;
	BarrierDirection = struct Up|Down;
	Track = struct Track1|Track2;
	Direction = struct EastToWest|WestToEast;

map	isOccupied : Track # Set(Track) -> Bool;
	makeOccupied : Track # Set(Track) -> Set(Track); 
	removeOccupied : Track # Set(Track) -> Set(Track);
	opp: Track -> Track;

var	o: Set(Track);
	t: Track;

eqn	isOccupied(t, o) = t in o;
	makeOccupied(t, o) = {t} + o;
	removeOccupied(t, o) = o - {t};
	opp(Track1) = Track2;
	opp(Track2) = Track1;


	
act 	% External
	lightSetPower : LightStatus;
	bellSetPower : BellStatus;
	barrierMove : BarrierDirection;
	sensorTrainEnter : Track # Direction;
	sensorTrainLeave: Track # Direction;
	%sensorTrainOnCrossing;

	% Internal


proc	SensorEnter(o: Set(Track)) = sum t: Track, d: Direction
		. isOccupied(t, o) -> delta
	%+	isOccupied(opp(t)) ->  % at what stage can we hook in?: light, bell, barrier..?
	+ sum t: Track, d: Direction .	(!isOccupied(t, o) && !isOccupied(t, o)) -> Light(LightOn, makeOccupied(t,o)) % TODO: set occupied
	;

	Light(s: LightStatus, o: Set(Track)) = 
		(s == LightOn) -> (
			({} <= o) -> lightSetPower(LightOn) . Bell(BellOn, o)
		)
		+ (s == LightOff) -> (
			Bell(BellOff, o)
		);

	Bell(s: BellStatus, o: Set(Track)) =
		(s == BellOn) -> (
			({} <= o) -> bellSetPower(BellOn) . Barrier(Up)
		)
		+ (s == BellOff) -> (
			delta
		);


	Barrier(s: BarrierDirection) = delta;

	SensorLeave(o: Set(Track)) = delta;

	

init SensorEnter({}) || SensorLeave({});